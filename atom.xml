<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Blog On The Way`]]></title>
  <link href="http://libelosophy.github.io/atom.xml" rel="self"/>
  <link href="http://libelosophy.github.io/"/>
  <updated>2013-10-12T16:06:01+08:00</updated>
  <id>http://libelosophy.github.io/</id>
  <author>
    <name><![CDATA[JH]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android 序列化 -- Parcelable]]></title>
    <link href="http://libelosophy.github.io/blog/2013/10/12/android-parcelable/"/>
    <updated>2013-10-12T12:08:00+08:00</updated>
    <id>http://libelosophy.github.io/blog/2013/10/12/android-parcelable</id>
    <content type="html"><![CDATA[<h3>序列化</h3>

<ul>
<li><p>为什么要序列化？</p>

<ol>
<li> 永久性保存对象，保存对象的 <em>字节序列</em> 到本地文件中</li>
<li> 通过序列化在网络中传递对象。</li>
<li> 通过序列化在进程间传递对象。</li>
</ol>
</li>
<li><p>序列化：
将数据结构或者对象 state 转换成可以存储的格式（如文件，memory buffer，或者在网络上传输），之后再在相同的计算机或者不同的计算机环境中恢复。当生成的bits序列按 <em>serilization 格式</em>被重新读出时，它可以创建一个语义唯一（semantically identical） 的原始对象的克隆。    <br/>
序列化的过程也被叫做 deflating 或者 marshalling 。相反的操作则叫做 deserialization （也叫做 inflating 或者 unmarshalling ）。</p></li>
<li><p><em>序列化格式</em>:</p>

<ul>
<li>XML , 有常规的xml(human readable text-based encoding,可以用文本编辑器打开) 和 Binary xml。在20世纪，XML经常被用于Ajax网站应用的客户端和服务器之间的数据结构的异步传输。</li>
<li>JSON， 是一个较之于XML 更加轻量级的序列化格式，JSON 也普遍被用于web 应用的C/S通讯， JSON 基于JavaScript 语法格式，不过也支持其他编程语言。</li>
<li>YAML， 高效的JSON超集，包括了一些特性使得它拥有更加强大的序列化功能，对人更加友好，拥有更好的潜在兼容性。</li>
<li>MAC OS X Cocoa..
</br>
</br></li>
</ul>
</li>
<li><p><em>编程语言支持</em></p>

<ul>
<li>Java &mdash; java.io.Serializable interface &hellip;</li>
<li>&hellip;</li>
</ul>
</li>
</ul>


<p>参考：wiki百科 <a href="http://en.wikipedia.org/wiki/Serialization">Serilization</a></p>

<hr />

<p></br></p>

<h3>安卓序列化</h3>

<ul>
<li>Android 序列化的两种方法

<ol type="a">
<li> Serializable 接口</li>
<li> <a href="http://developer.android.com/reference/android/os/Parcelable.html">Parcelable</a> 接口</li>
</ol>
</li>
</ul>


<h4>实现 Parcelable 接口实现安卓序列化</h4>

<ul>
<li>implemnts Parceable</li>
<li><p>需要序列化的类必须有一个 static field ： CREATEOR （ CREATEOR 是一个实现了Parcelable.Creator 接口的对象）</p></li>
<li><p>代码示例：</p>

<ul>
<li>目的： 实现 Parcelable 接口用于进程间（？）传递对象。程序的运行流程是： 点击MyParcelable 的button ，启动ActivityB 并将一个Person 实例传递过去，然后再再ActivityB 中将收到的Person 对象的信息显示在Textview 上。</li>
<li>主要结构： 一个Project， 建两个Activity&mdash; MyParcelable，ActivityB 。 MyParcelable 布局中添加一个button， 为Button 添加属性:   <br/>
android:onClick=&ldquo;onClick&rdquo;     <br/>
ActivityB 的xml 布局里添加一个TextView。     <br/>
一个 Person 类实现 Parcelable 接口。</li>
<li>代码：</li>
</ul>
</li>
</ul>


<p>MyParcelable :</p>

<pre><code>public class MyParcelable extends Activity implements OnClickListener {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.main, menu);
        return true;
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
        case R.id.btn1:
            Intent intent = new Intent();
            intent.setClass(this, ActivityB.class);
            Bundle extras = new Bundle();
            extras.putParcelable(Person.PARCELABLE_KEY, new Person("Libelosophy", 100));
            intent.putExtras(extras);
            startActivity(intent);
        }
    }
}
</code></pre>

<p>ActivityB :</p>

<pre><code>public class ActivityB extends Activity {
    private TextView tv = null;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_activity_b);
        tv = (TextView) findViewById(R.id.textview);

        Person person = getIntent().getExtras().getParcelable(Person.PARCELABLE_KEY);
        String person_info = "Name: " + person.getmName() 
                                + "\n Age: " + person.getmAge();

        tv.setText(person_info);

        }       
}
</code></pre>

<p>Person :</p>

<pre><code>public class Person  implements Parcelable {
    public static final String PARCELABLE_KEY = "PersonParcelableObject";

    private String mName;
    private int mAge;


    public String getmName() {
        return mName;
    }

    public void setmName(String mName) {
        this.mName = mName;
    }

    public int getmAge() {
        return mAge;
    }

    public void setmAge(int mAge) {
        this.mAge = mAge;
    }

    Person(String name, int age) {
        setmName(name);
        setmAge(age);
    }



    private Person(Parcel in) {

        setmName(in.readString());
        setmAge(in.readInt());
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(getmName());
        dest.writeInt(getmAge());
    }

    public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.Creator&lt;Person&gt;() {

        @Override
        public Person createFromParcel(Parcel source) {

            return new Person(source);
        }

        @Override
        public Person[] newArray(int size) {

            return new Person[size];
        }
    };

}
</code></pre>

<p>运行结果： 如预期。</p>

<ul>
<li>实例</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unix programming ]]></title>
    <link href="http://libelosophy.github.io/blog/2013/09/19/unix-programming/"/>
    <updated>2013-09-19T10:00:00+08:00</updated>
    <id>http://libelosophy.github.io/blog/2013/09/19/unix-programming</id>
    <content type="html"><![CDATA[<h2>书籍</h2>

<ul>
<li><p>Adcanced Progamming in the UNIX Environment (Second Edition) &mdash;W.Richard Stevens , Stephen A. Rago</p></li>
<li><p>Advanced UNIX Programming (Second Edition)  &mdash;Marc J. Rochking</p></li>
<li><p>Linux 程序员手册 通过 man 命令可查看</p></li>
</ul>


<p><em>参考</em></p>

<ol>
<li>[www.unix.org] (<a href="http://www.unix.org">http://www.unix.org</a>)   <br/>
<a href="http://vdisk.weibo.com/s/BJfv-cwfN3MXe"> 下载好的2013版html susv4</a>     <br/>
<a href="http://vdisk.weibo.com/s/BJfv-cwfN4uxq">04版 susv3</a>    <br/>
<a href="http://pubs.opengroup.org/onlinepubs/009695399/toc.htm">suv3在线查看</a></li>
</ol>


<p></br>
2. c 语言：<a href="http://vdisk.weibo.com/s/BJfv-cwfN3NpO"> C A reference manual </a>
3. c++ The C++ Programming Language</p>

<h2>UNIX 高级环境编程的内容</h2>

<ol type="a">
<li><p>系统调用接口</p></li>
<li><p>(标准C)库函数</p></li>
</ol>


<p>两本书中,有一本只准备讲系统调用,而故意忽略标准Ｃ库函数.那么系统掉调用和库函数的区别在哪儿呢?</p>

<ul>
<li>各种版本的UNIX 实现都提供了定义明确、数量有限、可直接进入内核的入口点。这些入口点就称为系统调用（System Call）</li>
<li>UNIX  为每个系统调用在标准Ｃ库中设置一个具有同样名字的函数，这些函数可能会调用一个或多个系统调用。</li>
<li>系统调用会产生两次模式切换（用户&mdash;内核，内核拥有最高级别权限）,但是不一定会产生上下文切换<a href="http://en.wikipedia.org/wiki/System_call#Processor_mode_and_context_switching" title="进程模型和上下文切换">?wiki</a></li>
<li>而库函数调用<a href="http://en.wikipedia.org/wiki/System_call#The_library_as_an_intermediary" title="系统调用作为中介">本身不会产生模式切换</a>,因为它工作在用户模式.不过如果该库函数调用系统调用,则会产生.</li>
<li>系统调用通常提供一种最小接口,而库函数通常提供比较复杂的功能.</li>
<li>POSIX 标准中包含 ISO C.</li>
<li>几个例子说明系统调用和库函数的区别:(UNIX高级环境编程)

<ol>
<li>malloc 存储器分配函数调用了 sbrk 系统调用实现了一种特定的存储分配方式,不过你也可以用 sbrk 实现其他的存储分配方式</li>
<li>UNIX 系统只提供一个获取时间的系统调用,该系统调用返回国际标准时间 1970.1.1 零点以来经过的所有秒数,而各种库函数则可以对这个数值进行各种解释,如转换为人类可读的形式,或者夏時制算法等等.</li>
</ol>
</li>
</ul>


<h2>unix 标准化</h2>

<ul>
<li>ISO C</li>
</ul>


<p>ISO: International Organizaition for Standardization 国际标准化组</p>

<p>提供Ｃ 程序的可移植性,使其适合于大量不同操作系统
定义了Ｃ 程序语言的设计语法和语义 及 其标准库</p>

<ul>
<li>IEEE POSIX</li>
</ul>


<p>IEEE : Institute of Electrical and Electronics Engineers 电子与电气工程师协会</p>

<p>POSIX: Portable Operating System Interface 可移植操作系统接口 X表示对ＵＮＩＸ API 的传承</p>

<p>提高应用程序在各ＵＮＩＸ 系统环境之间的可移植性.
定义了遵从ＰＯＳＩＸ 的操作系统所必须提供的各种服务.</p>

<ul>
<li>Single UNIX Specification
单一UNIX 规范 ,是POSIX.1 标准的一个超集. 亦称(XSI) X/Open System Interface</li>
</ul>


<h2>UNIX 基础之 文件系统</h2>

<ul>
<li>文件类别:

<ul>
<li>常规文件</li>
<li>目录</li>
<li>符号连接</li>
<li>特殊文件</li>
<li>命名管道(FIFO)</li>
<li>套接字文件(socket)</li>
</ul>
</li>
</ul>


<h2>文件 I/O (不带缓冲的I/O)</h2>

<p>不带缓冲: 每个read 和 write 都调用内核中的一个系统调用</p>

<ul>
<li>内容:

<ul>
<li>open</li>
<li>create</li>
<li>close</li>
<li>lseek</li>
<li>read</li>
<li>write</li>
<li>dup dup2</li>
<li>sync fsync fdatasync</li>
<li>fcntl</li>
<li>ioctl</li>
</ul>
</li>
</ul>


<p><em>文件描述符</em><br/>
内核使用 <em>文件描述符</em> 来引用打开的文件，文件描述符是一个整数      <br/>
&mdash; 当系统 打开一个现有文件或者创建一个新的文件时（open ，create），内核向进程返回一个文件描述符。<br/>
&mdash; 当读或写一个文件时，将标识一个文件的文件描述符作为参数传递给read 或 write</p>

<h3>open</h3>

<hr />

<pre><code>#inlcude &lt;fcntl.h&gt;

int open(const char * path, int oflag, .../* mode_t mode */);
int openat(int fd, const char * path, int oflag, ...);// relative to directory file descriptor
</code></pre>

<p>文件和文件描述符之间的连接桥梁，它会创建一个打开的文件描述符，该文件描述符关联这个打开的文件。文件描述符被用于其他IO 功能中引用文件。
默认的文件偏移别设置在文件的开始处</p>

<p><em>path</em>  &mdash;  points to a pathname nameing the file     <br/>
<em>oflag</em> &mdash; file status flags and file access modes of the open file description shall be set according to the value of <em>oflag</em></p>

<p>Vlaues of <em>oflags</em> (bitwise-inclusive OR of flags , defined in fcntl.h)   <br/>
Application shall specify exactly one of the first five(susv4) or three(susv3) values (file access modes) below in the value of oflag:</p>

<ul>
<li><p>三个必选其一的 access mode ：</p>

<ul>
<li>O_RDONLY</li>
<li>O_RDWR &mdash;  Open for reading and writing, The result is undefined if this flag is applied to a FIFO(命名管道)</li>
<li>O_WRONLY</li>
</ul>
</li>
<li><p>add in susv4</p>

<ul>
<li>O_EXEC &mdash; Open for execute only (non-directory files), the result is unspecified if this flag is applied to a directory.</li>
<li>O_SEARCH &mdash; open directory for search only, The result is unspecified if the flag is applied to a non-directory file.</li>
</ul>
</li>
<li><p>可选组合：</p>

<ul>
<li>O_APPEND &mdash; if set , the file offset shall be set to the end of the file prior to each write. （如果设置的话， 文件偏移会被设置到文件末尾）</li>
<li>O_CLOEXEC &mdash; if set, FD_CLOEXEC flag for the new file descriptor shall be set</li>
<li>O_CREATE &mdash; If file exists, this flag has no effect except as noted under O_EXCL below. Otherwise, the file shall be create; the user ID of the file shall be set to the effective user ID of the process ; the group ID of the file shall be set to the group ID of the file&rsquo;s parent directory or to the effective group ID of the process; and the access permisssion bits (see sys/stat.h) of the file mode shall be set to the value of the argument following oflag taken as type mode_t modified as follow: a bitwise AND is performed on the file-mode bits and the corresponding bits in the complement of the process&rsquo;s file mode bits creationg mask is set are cleared .  When bits other than the file permission bits are set, the effect if unspecified. the argument following the oflag does not affect whether the file is open for reading, writing, or for both. Implementions shall provide a way to initailize the file&rsquo;s group ID to the group ID of the parent directory.Implementations may , but need not , provider an implementation-defined way to initialize the file&rsquo;s group ID to the effective group ID of the calling process.</li>
<li>O_DIRECTORY &mdash; IF  path resolves to a non-directory file , fail and set errno to [ENOTDIR]</li>
<li>O_DSYNC &mdash; Write I/O operations on the file descriptor shall complete ad defined by synchronized I/O data integrity completion. 使每次I/O 等待物理I/O 操作完成，但是如果写操作并不影响读取刚写入的数据，则不等待文件属性被更新。</li>
<li>O_EXCL &mdash;</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SICP]]></title>
    <link href="http://libelosophy.github.io/blog/2013/09/16/sicp/"/>
    <updated>2013-09-16T17:41:00+08:00</updated>
    <id>http://libelosophy.github.io/blog/2013/09/16/sicp</id>
    <content type="html"><![CDATA[<h2>计算机程序的解释与构造 </h2>

<h2>Books online</h2>

<ul>
<li><a href="http://www.cs.berkeley.edu/~bh/ss-toc2.html" title="SSICS">Simply Scheme : Introducing Computer Science</a></li>
<li><a href="http://mitpress.mit.edu/sicp/full-text/book/book.html" title="SICP">Structure and Interpretation of Computer Programs</a></li>
</ul>


<p>PS: <a href="http://blog.csdn.net/johnhomsea/article/details/8950121" title="计算机程序的解释与构造">An introdution</a></p>

<h2>Install Scheme</h2>

<p>参考页面：<a href="http://caisah.info/emacs-for-sicp-scheme/" title="install scheme">How to get your environment ready for SICP (Structure and Interpretation of Computer Programs) course and Configure Emacs for Scheme programming</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Work with Git]]></title>
    <link href="http://libelosophy.github.io/blog/2013/09/15/how-to-work-with-git/"/>
    <updated>2013-09-15T12:18:00+08:00</updated>
    <id>http://libelosophy.github.io/blog/2013/09/15/how-to-work-with-git</id>
    <content type="html"><![CDATA[<h2>如何使用GIT </h2>

<ul>
<li>註冊:  到 <a href="https://github.com" title="github">github</a> 註冊一個帳號。</li>
<li>在你的github 頁面新建一個 repository</li>
</ul>


<p><img src="http://libelosophy.github.io/images/blog/create_repo.png" alt="create repo" /></p>

<p>點擊中間那個帶有 + 的圖標，爲repo 取名，添加描述，確認。</p>

<p>假設repo 名爲<em>project</em>。</p>

<ul>
<li><p>安裝 git ：</p></li>
<li><p>Windows ： 下載  <a href="https://code.google.com/p/msysgit/downloads/list" title="msysgit">msysgit</a></p></li>
<li><p>Linux :</p>

<ul>
<li><p>ubuntu :</p>

<p>  sudo apt-get install git</p></li>
</ul>
</li>
<li><p>git 本地操作。</p></li>
</ul>


<p> window 打開git-bash.bat, linux 打開終端。執行以下操作：</p>

<pre><code>mkdir workspace
cd workspace
git clone https://github.com/libelosophy/AndroidFileExplorer.git 
cd AndroidFileExplorer
git remote add origin https://github.com/*你的用戶名*/project.git # project 爲repo 名
git add .
git commit -m "提交說明，可以隨便寫“

# 代碼push 到你的 github 遠程repo 上。
git push origin master 
</code></pre>

<p>然後在eclipse 中導入項目，目錄選擇AndroidFileExplorer.
完成後進行開發。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu install &amp; use emacs24]]></title>
    <link href="http://libelosophy.github.io/blog/2013/09/15/ubuntu-install-and-use-emacs24/"/>
    <updated>2013-09-15T00:37:00+08:00</updated>
    <id>http://libelosophy.github.io/blog/2013/09/15/ubuntu-install-and-use-emacs24</id>
    <content type="html"><![CDATA[<h3>1. Ubuntu install emacs24 from source code</h3>

<pre><code># get source code       
wget http://mirrors.ustc.edu.cn/gnu/emacs/emacs-24.3.tar.xz

# extract
tar -xvf emacs-24.3.tar.xz
cd emac-24.3

# install x toolkit support lib and other (libtinfo is required)
sudo apt-get install libgtk2.0-dev
sudo apt-get install libtinfo-dev

# configure 
./configure --with-xpm=no --with-jpeg=no --with-gif=no --with-tiff=no

# make 
make 

# Test if emacs works
src/emacs -Q

# install 
sudo make install 

# Test if install is succed
emacs

# clean the output
make clean

# save the source code 
sudo mv emacs-24.3 /usr/local/src
</code></pre>

<h3>2. Basic usage</h3>

<ul>
<li>一般用法 CONTROL + &lt;chr>
  两种 CONTROL ：

<ul>
<li>CTRL /CTL ：Ctrl</li>
<li>META: Meta / Edit / Alt</li>
</ul>
</li>
<li>退出 编辑的session ： C-c C-x</li>
<li>下一页： C-v (View next page)</li>
<li>上一页： M-v</li>
<li>页内移动：

<ol>
<li> previous : C-p 前一行</li>
<li> next : C-n 后一行</li>
<li> backward : C-b 前移</li>
<li> forword : C-f 后移 中央聚焦： C-l 使光标所在处显示在屏幕中央</li>
<li><p> 字移动 ：M-b 以字为为单位向后移动（中文是移到下个标点，下同） : M-f word forward</p></li>
<li><p> C-a, C-e : 移动到行开始，行结束</p></li>
<li><p> M-a, M-e : 移动到上一句，下一句</p></li>
<li><p> M-&lt; : 文字开始 Alt+ shift + ,</p></li>
<li><p> M-> : 文字结束 Alt+ shift + .</p></li>
</ol>
</li>
<li><p>重复： C-u 数字 C-&lt;chr> 例外： C-u &lt;num> C-v/M-v 是卷动 num 行，而不是 num 页</p></li>
<li><p>停止/取消数字参数/ 撤销ESC： C-g</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
